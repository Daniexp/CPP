#ifndef AMATERIA_H
#define AMATERIA_H

#include <iostream>
#include <string>
#include "ICharacter.hpp"
class ICharacter;

class AMateria
{
public:
	AMateria();
   virtual ~AMateria();
   AMateria(const AMateria& src);
   AMateria(std::string const & type);
   AMateria& operator=(const AMateria & src);
   std::string const & getType() const;
   virtual AMateria* clone() const = 0;
   virtual void use(ICharacter & target);
private:

protected:
	std::string type;
};
std::ostream& operator << (std::ostream& os, const AMateria& A);
#endif     //AMATERIA_H
#ifndef CHARACTER_H
#define CHARACTER_H

#include <iostream>
#include <string>
#include <ICharacter.hpp>
class Character : public ICharacter
{
public:
	Character();
	virtual ~Character();
	Character(const std::string& Name);
   Character(const Character& src);
   Character& operator=(const Character& src);
	virtual std::string const & getName() const;
	virtual void equip(AMateria* m);
	virtual void unequip(int idx);
	virtual void use(int idx, ICharacter& target);
	virtual AMateria* getMateria(int idx);
private:
	AMateria* inventory[4];
	int numMat;
};

#endif     //CHARACTER_H
#ifndef CURE_H
#define CURE_H

#include <iostream>
#include <string>
#include <AMateria.hpp>
class Cure : public AMateria
{
public:
	Cure();
	virtual ~Cure();
   Cure(const Cure& src);
   Cure& operator=(const Cure& src);
   virtual AMateria* clone() const;
   virtual void use(ICharacter& target);
private:

};

#endif     //CURE_H
#ifndef ICHARACTER_H
#define ICHARACTER_H

#include <iostream>
#include <string>
#include <AMateria.hpp>

class AMateria;

class ICharacter
{
public:
	virtual ~ICharacter();
	virtual std::string const & getName() const = 0;
	virtual void equip(AMateria* m) = 0;
	virtual void unequip(int idx) = 0;
	virtual void use(int idx, ICharacter& target) = 0;
	virtual AMateria* getMateria(int idx);
protected:
	std::string name;
};
#endif     //ICHARACTER_H
#ifndef IMATERIASOURCE_H
#define IMATERIASOURCE_H

#include <iostream>
#include <string>
#include <AMateria.hpp>
class IMateriaSource
{
public:
	//IMaterialSource();
	virtual ~IMateriaSource();
   //IMaterialSource(const IMaterialSource& src);
   //IMaterialSource& operator=(const IMaterialSource& src);
   virtual void learnMateria(AMateria*) = 0;
   virtual AMateria* createMateria(std::string const & type) = 0;
private:

};

#endif     //IMATERIALSOURCE_H
#ifndef ICE_H
#define ICE_H

#include <iostream>
#include <string>
#include <AMateria.hpp>
class Ice : public AMateria
{
public:
	Ice();
	virtual ~Ice();
   Ice(const Ice& src);
   Ice& operator=(const Ice& src);
   virtual AMateria* clone() const;
   virtual void use(ICharacter& target);
private:

};

#endif     //ICE_H
#ifndef MATERIASOURCE_H
#define MATERIASOURCE_H

#include <iostream>
#include <string>
#include <IMateriaSource.hpp>
#include <AMateria.hpp>
class MateriaSource : public IMateriaSource
{
public:
	MateriaSource();
	virtual ~MateriaSource();
   MateriaSource(const MateriaSource& src);
   MateriaSource& operator=(const MateriaSource& src);
   virtual void learnMateria(AMateria* src);
   virtual AMateria* createMateria(std::string const & type);
protected:
	AMateria* materia[4];
	int num_mat;
	std::string materiaName[2];
};

#endif     //MATERIALSOURCE_H
#ifndef MATERIALSOURCE_H
#define MATERIALSOURCE_H

#include <iostream>
#include <string>
#include <IMateriaSource.hpp>
class MateriaSource : public IMateriaSource
{
public:
	MateriaSource();
	virtual ~MateriaSource();
   MateriaSource(const MateriaSource& src);
   MateriaSource& operator=(const MateriaSource& src);
   virtual void learnMateria(AMateria*);
   virtual AMateria* createMateria(std::string const & type);
protected:
	AMateria* materia[4];
	int num_mat;
	std::string materiaName[2];
};

#endif     //MATERIALSOURCE_H
#ifndef EX03_H
#define EX03_H
# include <iostream>
typedef std::basic_string<char> str;

#endif
#include <AMateria.hpp>


AMateria::AMateria()
{
	std::cout << "Default Constructor AMateria" << std::endl;
	type = "";
}

AMateria::AMateria(const AMateria& src)
{
//Copy Const
	*this = src;
	std::cout << "AMateria Copy Constructor";
}

AMateria::AMateria(std::string const & type)
{
	this->type = type;
	std::cout << "Type Constructor AMateria" << std::endl;
}

AMateria::~AMateria()
{
//Dest
	std::cout << "Destructor AMateria" << std::endl;
}

AMateria& AMateria::operator = (const AMateria& src)
{
	if (this != &src)
		type = src.type;
	return *this;
}

std::string const & AMateria::getType() const
{
	return type;
}

void AMateria::use(ICharacter& target)
{
	std::cout << "* Nothing happened to " << target.getName() << std::endl;
}

std::ostream& operator << (std::ostream& os, const AMateria& A)
{
	os << "I'm type -> " << A.getType() << std::endl;
	return os;
}
#include <Character.hpp>


Character::Character()
{
//Copy Const
	std::cout << "Copy Constructor Character" << std::endl;
	name = "";
	numMat = 0;
	for (int i=0; i < 4; i++)
		inventory[i] = nullptr;
}

Character::Character(const Character& src)
{
	*this = src;
}

Character::~Character()
{
//Dest
	std::cout << "Destructor Character" << std::endl; 
	for (int i=0; i < numMat; i++)
		delete inventory[i];
}

Character& Character::operator = (const Character& src)
{
	if (this != &src)
	{
		numMat = src.numMat;
		for (int i=0; i < numMat; i++)
		inventory[i] = src.inventory[i]->clone();
	}
	return *this;
}

Character::Character(const std::string& Name)
{
	this->name = Name;
	numMat = 0;
	for (int i=0; i < 4 ; i++)
		inventory[i] = nullptr;
}

std::string const& Character::getName() const
{
	return (this->name);
}

void Character::equip(AMateria* m)
{
	if (numMat < 4 && m != nullptr)
		inventory[numMat++] = m;
}

void Character::unequip(int idx)
{
	if (idx < numMat && idx > -1 && idx < 4)
		inventory[idx] = nullptr;
}

void Character::use(int idx, ICharacter& target)
{
	if (idx < numMat && inventory[idx] != nullptr)
			inventory[idx]->use(target);
}

AMateria* Character::getMateria(int idx)
{
	if (idx >= 0 && idx < numMat)
		return inventory[idx];
	return nullptr;
}
#include <Cure.hpp>

Cure::Cure() : AMateria("cure")
{
//Const
	std::cout << "Default Constructor Cure" << std::endl;
}

Cure::Cure(const Cure& src)
{
//Copy Const
	std::cout << "Copy Constructor Cure" << std::endl;
	*this = src;
}

Cure::~Cure()
{
//Dest
	std::cout << "Destructor Cure" << std::endl;
}

Cure& Cure::operator = (const Cure& src)
{
	AMateria::operator=(src);
	return *this;
}

AMateria* Cure::clone() const
{
	return new Cure();
}

void Cure::use(ICharacter& target)
{
	std::cout << "* heals " << target.getName() << "'s wounds *" << std::endl;	
}
#include <ICharacter.hpp>

/*
ICharacter::ICharacter()
{
//Const
	name = "";
	numMat = 0;
	for (int i=0; i < 4; i++)
		inventory[i] = nullptr;
}

ICharacter::ICharacter(const ICharacter& src)
{
//Copy Const
	*this = src;
	std::cout << "Copy Constructor ICharacter" << std::endl;
}
*/

ICharacter::~ICharacter()
{
//Dest
	std::cout << "Destructor ICharacter" << std::endl;
}

AMateria* ICharacter::getMateria(int idx)
{
	if (idx < 0)
		idx++;
	return nullptr;	
}

/*
ICharacter& ICharacter::operator = (const ICharacter& src)
{
	if (this != &src)
	{
		for (int i=0; i < 4; i++)
			inventory[i] = src.inventory[i]->clone();
		numMat = src.numMat;
	}
	return *this;
}
*/
#include <IMateriaSource.hpp>

/*
IMaterialSource::IMaterialSource()
{
//Const
}
IMaterialSource::IMaterialSource(const IMaterialSource& src)
{
//Copy Const
	*this = src;
}
*/
IMateriaSource::~IMateriaSource()
{
//Dest
}
/*
IMaterialSource& IMaterialSource::operator = (const IMaterialSource& src)
{
	return *this;
}
*/
#include <Ice.hpp>

Ice::Ice() : AMateria("ice")
{
//Const
}

Ice::Ice(const Ice& src) : AMateria(src)
{
//Copy Const
	//*this = src;
	std::cout << "Copy Constructor Ice" << std::endl;
}

Ice::~Ice()
{
//Dest
}

Ice& Ice::operator = (const Ice& src)
{
	AMateria::operator=(src);
	return *this;
}

AMateria* Ice::clone() const
{
	return new Ice();
}

void Ice::use(ICharacter& target)
{
	std::cout << "* shoots an ice bolt at " << target.getName() << " *" << std::endl;
}
#include <MateriaSource.hpp>
#include <Ice.hpp>
#include <Cure.hpp>

MateriaSource::MateriaSource()
{
//Const
	num_mat = 0;
	materiaName[0] = "ice";
	materiaName[1] = "cure";
	for (int i=0; i < 4; i++)
		materia[i] = nullptr;
}

MateriaSource::MateriaSource(const MateriaSource& src)
{
//Copy Const
	*this = src;
}

MateriaSource::~MateriaSource()
{
//Dest
	std::cout << "Destructor MaterialSource()" << std::endl;
	for (int i=0 ; i < num_mat ; i++)
		delete materia[i];
}

MateriaSource& MateriaSource::operator = (const MateriaSource& src)
{
	if (this != &src)
	{
		num_mat = src.num_mat;
		for (int i=0; i < num_mat; i++)
			materia[i] = src.materia[i]->clone();
	}
	return *this;
}

void MateriaSource::learnMateria(AMateria* src)
{
	if (src != nullptr && num_mat < 4)
		materia[num_mat++] = src;
}

AMateria* MateriaSource::createMateria(std::string const & type)
{
	if (type == "ice")
		return new Ice();
	else if (type == "cure")
		return new Cure();
	return nullptr;
}
#include <ex03.hpp>
#include <MateriaSource.hpp>
#include <IMateriaSource.hpp>
#include <ICharacter.hpp>
#include <Character.hpp>
#include <Cure.hpp>
#include <Ice.hpp>
#include <AMateria.hpp>
int main(void)
{
 IMateriaSource* src = new MateriaSource();

    // Learning new Materias
    src->learnMateria(new Ice());
    src->learnMateria(new Cure());

    // Creating a new Character
    ICharacter* me = new Character("me");

    // Equipping Materias
    AMateria* tmp;
    tmp = src->createMateria("ice");
    me->equip(tmp);
    tmp = src->createMateria("cure");
    me->equip(tmp);

    // Creating a new Character
    ICharacter* bob = new Character("bob");

    // Using Materias on bob
    me->use(0, *bob);
    me->use(1, *bob);

    // Equipping additional Materias
    tmp = src->createMateria("ice");
    me->equip(tmp);
    tmp = src->createMateria("ice");
    me->equip(tmp);

    // Using Materias on bob and the Character itself
    me->use(0, *bob);
    me->use(1, *bob);
    me->use(2, *me);
    me->use(3, *me);

    // Trying to equip a Materia in a full inventory slot
    tmp = src->createMateria("cure");
    me->equip(tmp);

    // Trying to use an unexisting Materia slot
    me->use(5, *bob);

    // Unequipping a Materia and using it on bob
	tmp = me->getMateria(0);
    me->unequip(0);
    me->use(0, *bob);
    me->equip(tmp);

    // Cloning a Materia and equipping it
    tmp = me->getMateria(1)->clone();
    //tmp = me->getMateria(1)->clone();
    me->equip(tmp);

    // Creating a new Character and trying to equip a Materia
    ICharacter* alice = new Character("alice");
    tmp = src->createMateria("cure");
    alice->equip(tmp);

    // Deleting objects
    delete alice;
    delete bob;
    delete me;
    delete src;

    return 0;
}
